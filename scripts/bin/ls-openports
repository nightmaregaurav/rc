#!/usr/bin/env -S uv run --script

# /// script
# requires-python = ">=3.14"
# dependencies = [
#   "psutil",
# ]
# ///

import os
import sys
import subprocess
from collections import OrderedDict

script_name = os.path.basename(sys.argv[0])

HELP_MSG = f"""Usage: {script_name}

Shows active network connections with application names.

Columns:
  Application | Source Address | Src Port | Dest Address | Dest Port | Proto

Examples:
  {script_name}
"""

# Show help
if len(sys.argv) > 1 and sys.argv[1] in ("--help", "-h"):
    print(HELP_MSG)
    sys.exit(0)


# Ensure running as root/admin
def is_root():
    if os.name == "nt":
        # On Windows, check via "net session" (requires admin)
        try:
            subprocess.check_output(
                "net session", shell=True, stderr=subprocess.DEVNULL
            )
            return True
        except subprocess.CalledProcessError:
            return False
    else:
        return os.geteuid() == 0


if not is_root():
    print(f"Re-running '{script_name}' with elevated privileges...")
    try:
        if os.name == "nt":
            # Relaunch via PowerShell as admin
            subprocess.run(
                [
                    "powershell",
                    "Start-Process",
                    sys.executable,
                    *sys.argv,
                    "-Verb",
                    "runAs",
                ]
            )
        else:
            os.execvp("sudo", ["sudo", sys.executable, *sys.argv])
    except Exception as e:
        print(f"Failed to elevate privileges: {e}")
    sys.exit(0)

try:
    import psutil
except ImportError:
    print("Error: 'psutil' module is required. Install it with 'pip install psutil'.")
    sys.exit(1)


def dash(n):
    return "-" * n


# Collect connections
connections = OrderedDict()
for conn in psutil.net_connections(kind="inet"):
    try:
        proc_name = psutil.Process(conn.pid).name() if conn.pid else "-"
    except Exception:
        proc_name = "-"

    laddr = conn.laddr.ip if hasattr(conn.laddr, "ip") else conn.laddr[0]
    lport = str(conn.laddr.port if hasattr(conn.laddr, "port") else conn.laddr[1])
    raddr = conn.raddr.ip if conn.raddr else "-"
    rport = str(conn.raddr.port if conn.raddr else "-")
    proto = "TCP" if conn.type == 1 else "UDP" if conn.type == 2 else str(conn.type)

    key = f"{proc_name}|{laddr}|{lport}|{raddr}|{rport}|{proto}"
    if key not in connections:
        connections[key] = (proc_name, laddr, lport, raddr, rport, proto)

# Determine column widths dynamically
columns = list(zip(*connections.values())) if connections else [[]] * 6
widths = [max(15, max((len(str(v)) for v in col), default=0)) for col in columns]
app_w, src_addr_w, src_port_w, dest_addr_w, dest_port_w, proto_w = widths

# Print header
print(
    f"{'Application':<{app_w}} {'Source Address':<{src_addr_w}} {'Src Port':<{src_port_w}} "
    f"{'Dest Address':<{dest_addr_w}} {'Dest Port':<{dest_port_w}} {'Proto':<{proto_w}}"
)
print(
    f"{dash(app_w):<{app_w}} {dash(src_addr_w):<{src_addr_w}} {dash(src_port_w):<{src_port_w}} "
    f"{dash(dest_addr_w):<{dest_addr_w}} {dash(dest_port_w):<{dest_port_w}} {dash(proto_w):<{proto_w}}"
)

# Print connections
for conn in connections.values():
    print(
        f"{conn[0]:<{app_w}} {conn[1]:<{src_addr_w}} {conn[2]:<{src_port_w}} "
        f"{conn[3]:<{dest_addr_w}} {conn[4]:<{dest_port_w}} {conn[5]:<{proto_w}}"
    )

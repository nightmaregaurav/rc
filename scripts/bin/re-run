#!/usr/bin/env -S uv run --script

# /// script
# requires-python = ">=3.14"
# dependencies = [
#     "argcomplete",
# ]
# ///

import os
import argparse
import argcomplete
import re
import subprocess
import time
import sys
import signal
import shlex
from shutil import get_terminal_size, which


def run_in_invoking_shell(commands: list[str]) -> subprocess.CompletedProcess:

    shell_path = os.environ.get("CURRENT_SHELL")
    if shell_path and which(shell_path):
        # Convert list -> properly escaped string
        cmd_str = " ".join(shlex.quote(arg) for arg in commands)
        # Pass the shell binary as executable, command as string
        return subprocess.run([shell_path, "-i", "-c", cmd_str])
    else:
        # Windows fallback, shell=True is required, command must be string
        return subprocess.run(commands, shell=True)


def parse_time_expression(expr: str) -> float:
    """Parses a time expression like '1h3s', '2minutes', '5m', etc. into seconds."""
    expr = expr.lower().replace(" ", "")
    pattern = r"(?:(\d+)\s*(?:h|hour|hours))?|(?:(\d+)\s*(?:m|minute|minutes))?|(?:(\d+)\s*(?:s|second|seconds))?"
    matches = re.findall(pattern, expr)
    if not matches:
        raise ValueError(f"Invalid time format: '{expr}'")

    total_seconds = 0
    for h, m, s in matches:
        if h:
            total_seconds += int(h) * 3600
        if m:
            total_seconds += int(m) * 60
        if s:
            total_seconds += int(s)
    if total_seconds == 0:
        raise ValueError(f"No valid time components found in '{expr}'")
    return total_seconds


def print_separator(char="_"):
    cols = get_terminal_size((80, 20)).columns
    print(char * cols)


def handle_exit(_, __):
    print("\nExit signal received. Stopping the loop...")
    sys.exit(0)


def repeat_command(interval_seconds: float, command: list[str]):
    """Runs the command repeatedly at the given interval."""
    print(f"Re-running every {interval_seconds} second(s). Press Ctrl+C to stop.")
    print_separator("=")

    signal.signal(signal.SIGINT, handle_exit)
    signal.signal(signal.SIGTERM, handle_exit)

    iteration = 1
    while True:
        print_separator("_")
        now=time.strftime("%Y-%m-%d %H:%M:%S", time.localtime())
        print(f"[Run #{iteration}] [{now}] Executing: {command}")
        result = run_in_invoking_shell(command)
        now=time.strftime("%Y-%m-%d %H:%M:%S", time.localtime())
        print(f"[Run #{iteration}] [{now}] Exit code: {result.returncode}")
        iteration += 1
        print_separator("*")
        time.sleep(interval_seconds)


def main():
    parser = argparse.ArgumentParser(
        description="Repeats a given command at regular intervals.",
        formatter_class=argparse.RawTextHelpFormatter,
        add_help=False,
    )

    parser.add_argument(
        "--every", "-e",
        required=True,
        metavar="<time>",
        help="Time interval between runs (e.g. 5s, 2m, 1h30s, 3hours10seconds)",
    )

    parser.add_argument(
        "command",
        nargs=argparse.REMAINDER,
        help="Command to execute repeatedly.",
    )

    parser.add_argument(
        "-h", "--help",
        action="help",
        help="Show help message and exit.",
    )

    argcomplete.autocomplete(parser, always_complete_options=False)
    args = parser.parse_args()

    if not args.command:
        print("Error: No command provided to re-run.", file=sys.stderr)
        sys.exit(1)

    try:
        interval_seconds = parse_time_expression(args.every)
    except ValueError as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)

    command = args.command
    repeat_command(interval_seconds, command)


if __name__ == "__main__":
    main()

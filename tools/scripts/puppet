#!/usr/bin/env -S uv run --script

# /// script
# requires-python = ">=3.14"
# dependencies = [
#     "argcomplete",
#     "pynput",
# ]
# ///

import argparse
import threading
from io import TextIOWrapper
import argcomplete
import sys
import time
from pynput.keyboard import Controller as Keyboard, Listener as KeyListener, Key, KeyCode
from pynput.mouse import Controller as Mouse, Listener as MouseListener, Button
import xml.etree.ElementTree as ElementTree
from dataclasses import dataclass


# ---------------------------
#  DATA CLASSES DECLARATION
# ---------------------------

@dataclass
class TextToken:
    text: str

@dataclass
class EventToken:
    tag: str
    attrs: dict[str, str]
    is_open: bool
    is_close: bool

keyboard = Keyboard()
mouse = Mouse()


# ---------------------------
#  STATE
# ---------------------------

last_position = None
last_pressed_key = None
start_ns = None  # start monotonic nanoseconds
print_file: TextIOWrapper | None = None


# ---------------------------
#  HELPERS
# ---------------------------

def print_event(text: str):
    if print_file is not None:
        print_file.write(text)
        print_file.flush()
    else:
        print(text, end="", flush=True)


def get_delay():
    global start_ns
    now_ns = time.monotonic_ns()
    if start_ns is None:
        start_ns = now_ns
        return 0
    diff_ns = now_ns - start_ns
    start_ns = now_ns
    return diff_ns // 1_000_000  # convert to milliseconds


def get_valid_key_names():
    base_keys = [key.name.upper() for key in Key]
    return sorted(set(base_keys))


def get_key_from_name(name: str) -> Key | None:
    valid_keys = get_valid_key_names()
    if name.upper() not in valid_keys:
        print(f"Warning: Key '{name}' is not a valid pynput Key.")
        return None
    try:
        return getattr(Key, name.lower())
    except AttributeError:
        print(f"Warning: Key '{name}' not found in pynput Key.")
        return None


def list_available_keys():
    keys = get_valid_key_names()
    print("Available keys:")
    for i, k in enumerate(keys, 1):
        print(f"{i:3}. {k}")
    print(f"\nTotal: {len(keys)} keys.")
    special_tags = {
        "<_/>": "Introduce a delay (default 500ms). Delay is modifiable with 'delay' attribute.",
    }
    print("\nSpecial tags:")
    for i, (tag, desc) in enumerate(special_tags.items(), 1):
        print(f"{i:3}. {tag}: {desc}")
    sys.exit(0)


# ---------------------------
#  TOKENIZER
# ---------------------------

def tokenize(command: str) -> list[TextToken | EventToken]:
    wrapped = f"<root>{command}</root>"
    root = ElementTree.fromstring(wrapped)
    tokens: list[TextToken | EventToken] = []

    def traverse(elem):
        if elem.tag != 'root':
            tokens.append(
                EventToken(
                    tag=elem.tag,
                    attrs=elem.attrib,
                    is_open=True,
                    is_close=False,
                )
            )

        if elem.text:
            tokens.append(TextToken(elem.text))

        for child in elem:
            traverse(child)

        if elem.tag != 'root':
            tokens.append(
                EventToken(
                    tag=elem.tag,
                    attrs={},
                    is_open=False,
                    is_close=True,
                )
            )

        if elem.tail:
            tokens.append(TextToken(elem.tail))

    traverse(root)

    return tokens


# ---------------------------
#  PLAY EVENT HANDLERS
# ---------------------------

def handle_event(event: EventToken):
    is_mouse_event = event.tag == 'MouseEvent'
    if is_mouse_event:
        handle_mouse_event(event)
    else:
        handle_key_event(event)


def handle_mouse_event(event: EventToken):
    if event.is_close:
        return  # nothing to do on close for mouse events

    action = event.attrs.get('action')
    x = float(event.attrs.get('x', '0'))
    y = float(event.attrs.get('y', '0'))
    if action == 'move':
        print(f"Moving mouse to ({x}, {y})")
        mouse.position = (x, y)
    elif action == 'click':
        button_name = event.attrs.get('button', 'left')
        button = getattr(Button, button_name.lower(), Button.left)
        button_event = event.attrs.get('event', 'pressed_and_released')
        if button_event == 'pressed':
            print(f"Pressing mouse button: {button_name} at ({x}, {y})")
            mouse.position = (x, y)
            mouse.press(button)
        elif button_event == 'released':
            print(f"Releasing mouse button: {button_name} at ({x}, {y})")
            mouse.position = (x, y)
            mouse.release(button)
        else:
            print(f"Clicking mouse button: {button_name} at ({x}, {y})")
            mouse.position = (x, y)
            mouse.click(button)
    elif action == 'scroll':
        dx = int(event.attrs.get('dx', '0'))
        dy = int(event.attrs.get('dy', '0'))
        print(f"Scrolling mouse at ({x}, {y}) by ({dx}, {dy})")
        mouse.position = (x, y)
        mouse.scroll(dx, dy)
    else:
        print(f"Warning: Unknown mouse action '{action}'.")


def handle_key_event(event: EventToken):
    key = get_key_from_name(event.tag)

    if not isinstance(key, Key):
        return

    if event.is_open:
        print(f"Pressing key: {key.name}")
        keyboard.press(key)
    elif event.is_close:
        print(f"Releasing key: {key.name}")
        keyboard.release(key)
    else:
        print(f"Warning: Invalid key event for tag '{event.tag}'.")


def start_playing(tokens: list[TextToken| EventToken]):
    for token in tokens:
        if isinstance(token, EventToken):
            is_delay_flag = token.tag == '_'
            if is_delay_flag and token.is_open:
                preferred_delay_ms = int(token.attrs.get('delay', '500'))
                print(f"Waiting for {preferred_delay_ms}ms")
                time.sleep(preferred_delay_ms / 1000)
            elif is_delay_flag and token.is_close:
                pass  # there is nothing to do on closing delay tag
            else:
                handle_event(token)
        else:
            for char in token.text:
                print(f"Typing character: {char}")
                keyboard.type(char)


# ---------------------------
#  RECORD EVENT HANDLERS
# ---------------------------

def handle_move(x, y):
    global last_position
    pos = (x, y)
    if pos != last_position:
        delay = get_delay()
        if delay > 0:
            print_event(f'<_ delay="{delay}"/>')
        print_event(f'<MouseEvent action="move" x="{x}" y="{y}"/>')
        last_position = pos


def handle_click(x, y, button, pressed):
    name = button.name.upper()
    pos = f'x="{x}" y="{y}"'

    if pressed:
        event = "pressed"
    else:
        event = "released"

    delay = get_delay()
    if delay > 0:
        print_event(f'<_ delay="{delay}"/>')
    print_event(f'<MouseEvent action="click" button="{name}" event="{event}" {pos}/>')


def handle_scroll(x, y, dx, dy):
    # Always print updated position before scroll
    handle_move(x, y)

    delay = get_delay()
    if delay > 0:
        print_event(f'<_ delay="{delay}"/>')
    print_event(f'<MouseEvent action="scroll" dx="{dx}" dy="{dy}" x="{x}" y="{y}"/>')


def handle_key_press(key: Key | KeyCode):
    global last_pressed_key

    delay = get_delay()
    if delay > 0:
        print_event(f'<_ delay="{delay}"/>')

    key_name = key.name.upper() if isinstance(key, Key) else key.char.upper()
    if key_name in get_valid_key_names():
        print_event(f"<{key_name}>")
    else:
        print_event(key_name)
    last_pressed_key = key


def handle_key_release(key: Key | KeyCode):
    global last_pressed_key

    key_name = key.name.upper() if isinstance(key, Key) else key.char.upper()
    if key_name in get_valid_key_names():
        delay = get_delay()
        if delay > 0:
            print_event(f'<_ delay="{delay}"/>')
        print_event(f"</{key_name}>")
    last_pressed_key = None


def on_move(x, y):
    handle_move(x, y)


def on_click(x, y, button, pressed):
    handle_click(x, y, button, pressed)


def on_scroll(x, y, dx, dy):
    handle_scroll(x, y, dx, dy)

def on_press(key: Key | KeyCode):
    handle_key_press(key)


def on_release(key: Key | KeyCode):
    handle_key_release(key)


def start_listening():
    # Start keyboard listener in a separate thread
    key_listener = KeyListener(on_press=on_press, on_release=on_release)
    key_thread = threading.Thread(target=key_listener.start)
    key_thread.start()

    # Start mouse listener in a separate thread
    mouse_listener = MouseListener(on_move=on_move, on_click=on_click, on_scroll=on_scroll)
    mouse_thread = threading.Thread(target=mouse_listener.start)
    mouse_thread.start()

    # Join threads to ensure the program waits for them to finish
    key_listener.join()
    mouse_listener.join()


# ---------------------------
#  MAIN LOGIC
# ---------------------------

def main():
    parser = argparse.ArgumentParser(
        description="Simulates keyboard and mouse events with XML-like tags.",
        formatter_class=argparse.RawTextHelpFormatter,
        add_help=False,
    )

    parser.add_argument("-h", "--help", action="help", help="Show help message and exit.")

    mode_group = parser.add_mutually_exclusive_group(required=True)

    mode_group.add_argument("-p", "--play", action="store_true", help="Play mode.")
    mode_group.add_argument("-r", "--record", action="store_true", help="Record mode.")
    mode_group.add_argument("-l", "--list", action="store_true", help="List all available key names.")

    command_group = parser.add_mutually_exclusive_group(required=False)

    command_group.add_argument(
        "-f", "--file",
        type=str,
        help="Macro file.",
    ).completer = argcomplete.completers.FilesCompleter(allowednames=["*.xml"])

    command_group.add_argument(
        "command",
        type=str,
        nargs="?",
        help="Puppet command string with valid syntax inside quotes.\nExample: 'Hello<SHIFT>World</SHIFT><ENTER/>'.",
    )

    argcomplete.autocomplete(parser, always_complete_options=False)
    args = parser.parse_args()

    # Check if command source is provided for play mode
    if args.play and not (args.file or args.command):
        parser.error('-p/--play requires either -f/--file or command string.')

    if args.list:
        list_available_keys()
        sys.exit(0)

    if args.file and args.play:
        with open(args.file, 'r', encoding='utf-8') as f:
            args.command = f.read()
    elif args.file:
        global print_file
        print_file = open(args.file, "w")

    if args.play:
        tokens = tokenize(args.command)
        print("Press Ctrl+C to stop.")
        start_playing(tokens)
    else:
        print("Press Ctrl+C to stop.")
        start_listening()


if __name__ == "__main__":
    main()

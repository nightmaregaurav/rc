#!/usr/bin/env -S uv run --script

# /// script
# requires-python = ">=3.14"
# dependencies = [
#     "argcomplete",
#     "pynput",
# ]
# ///

import argparse
import threading
from io import TextIOWrapper

import argcomplete
import time
from pynput.mouse import Listener as MouseListener, Button
from pynput.keyboard import Listener as KeyListener, Key, KeyCode

# ---------------------------
#  VARIABLES
# ---------------------------

specialKeys = [key.name.upper() for key in Key]

# ---------------------------
#  STATE
# ---------------------------

last_position = None
last_pressed_key = None
start_ns = None  # start monotonic nanoseconds
print_file: TextIOWrapper | None = None

# ---------------------------
#  HELPERS
# ---------------------------

def print_event(text: str):
    if print_file is not None:
        print_file.write(text)
        print_file.flush()
    else:
        print(text, end="", flush=True)

def get_delay():
    global start_ns
    now_ns = time.monotonic_ns()
    if start_ns is None:
        start_ns = now_ns
        return 0
    diff_ns = now_ns - start_ns
    start_ns = now_ns
    return diff_ns // 1_000_000  # convert to milliseconds


def format_button(button: Button):
    return button.name.upper()


# ---------------------------
#  EVENT HANDLERS
# ---------------------------

def handle_move(x, y):
    global last_position
    pos = (x, y)
    if pos != last_position:
        delay = get_delay()
        if delay > 0:
            print_event(f'<_ delay="{delay}"/>')
        print_event(f'<MouseEvent action="move" x="{x}" y="{y}"/>')
        last_position = pos


def handle_click(x, y, button, pressed):
    name = format_button(button)
    pos = f'x="{x}" y="{y}"'

    if pressed:
        event = "pressed"
    else:
        event = "released"

    delay = get_delay()
    if delay > 0:
        print_event(f'<_ delay="{delay}"/>')
    print_event(f'<MouseEvent action="click" button="{name}" event="{event}" {pos}/>')


def handle_scroll(x, y, dx, dy):
    # Always print updated position before scroll
    handle_move(x, y)

    delay = get_delay()
    if delay > 0:
        print_event(f'<_ delay="{delay}"/>')
    print_event(f'<MouseEvent action="scroll" dx="{dx}" dy="{dy}" x="{x}" y="{y}"/>')


def handle_key_press(key: Key | KeyCode):
    global last_pressed_key

    delay = get_delay()
    if delay > 0:
        print_event(f'<_ delay="{delay}"/>')

    key_name = key.name.upper() if isinstance(key, Key) else key.char.upper()
    if key_name in specialKeys:
        print_event(f"<{key_name}>")
    else:
        print_event(key_name)
    last_pressed_key = key


def handle_key_release(key: Key | KeyCode):
    global last_pressed_key

    key_name = key.name.upper() if isinstance(key, Key) else key.char.upper()
    if key_name in specialKeys:
        delay = get_delay()
        if delay > 0:
            print_event(f'<_ delay="{delay}"/>')
        print_event(f"</{key_name}>")
    last_pressed_key = None


def on_move(x, y):
    handle_move(x, y)


def on_click(x, y, button, pressed):
    handle_click(x, y, button, pressed)


def on_scroll(x, y, dx, dy):
    handle_scroll(x, y, dx, dy)

def on_press(key: Key | KeyCode):
    handle_key_press(key)


def on_release(key: Key | KeyCode):
    handle_key_release(key)


def start_listening():
    # Start keyboard listener in a separate thread
    key_listener = KeyListener(on_press=on_press, on_release=on_release)
    key_thread = threading.Thread(target=key_listener.start)
    key_thread.start()

    # Start mouse listener in a separate thread
    mouse_listener = MouseListener(on_move=on_move, on_click=on_click, on_scroll=on_scroll)
    mouse_thread = threading.Thread(target=mouse_listener.start)
    mouse_thread.start()

    # Join threads to ensure the program waits for them to finish
    key_listener.join()
    mouse_listener.join()


# ---------------------------
#  MAIN LOGIC
# ---------------------------

def main():
    parser = argparse.ArgumentParser(
        description="Captures key presses, mouse movements, clicks, and scrolls in a macro-friendly XML-like format.",
        formatter_class=argparse.RawTextHelpFormatter,
        add_help=False,
    )

    parser.add_argument("-h", "--help", action="help", help="Show help message and exit.")
    parser.add_argument(
        "-f", "--file",
        type=str,
        help="Output file to save the captured events. Defaults to stdout.",
    ).completer = argcomplete.completers.FilesCompleter(allowednames=["*.xml"])

    argcomplete.autocomplete(parser, always_complete_options=False)
    args = parser.parse_args()

    if args.file:
        global print_file
        print_file = open(args.file, "w")

    print("Press Ctrl+C to exit.")
    start_listening()


if __name__ == "__main__":
    main()



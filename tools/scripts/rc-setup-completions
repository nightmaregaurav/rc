#!/usr/bin/env -S uv run --script

# /// script
# requires-python = ">=3.14"
# dependencies = [
#     "argcomplete",
# ]
# ///

import argparse
import argcomplete
import os
import shutil
import subprocess
import sys
import tempfile
from pathlib import Path


# ---------------------------------
#  UTILITIES
# ---------------------------------

def get_commands():
    readme_path = Path(__file__).parent.parent.with_name("README.md")

    if not readme_path.is_file():
        print(f"Error: {readme_path} not found.", file=sys.stderr)
        sys.exit(1)

    content = readme_path.read_text(encoding="utf-8")
    lines = content.splitlines()

    start_extracting = False
    tools = []
    for line in lines:
        stripped = line.strip()

        # Start when we hit "### Tools"
        if stripped == "### Tools":
            start_extracting = True
            continue
        if not start_extracting:
            continue

        # Stop at any level-2 heading (## ...)
        if start_extracting and stripped.startswith("## "):
            break

        # If we're in the section and the line looks like a script entry, print it
        if start_extracting and line.lstrip().startswith("- `"):
            first_word = line.split()[1].replace("`", "").replace(":", "")
            tools.append(first_word)
    return tools


def ensure_argcomplete_installed():
    """Check if `register-python-argcomplete` exists."""
    if shutil.which("register-python-argcomplete") is None:
        print("ERROR: register-python-argcomplete not found in PATH.", file=sys.stderr)
        print("       Install it using:", file=sys.stderr)
        print("           uv tool install argcomplete", file=sys.stderr)
        sys.exit(1)


def generate_completions(commands: list[str], output_dir: Path):
    """Generate bash completion scripts for each command."""
    output_dir.mkdir(parents=True, exist_ok=True)

    # Cleanup existing files
    print("üßπ Removing old completions...")
    for f in output_dir.iterdir():
        if f.is_file():
            f.unlink()
    print(f"‚úÖ Cleared: {output_dir}\n")

    print(f"‚öôÔ∏è  Generating completions for {len(commands)} commands...\n")

    for cmd in commands:
        out_file = output_dir / f"{cmd}-completion.sh"

        # Create temp file in same directory
        fd, tmp_path = tempfile.mkstemp(prefix=f"{cmd}.", dir=str(output_dir))
        os.close(fd)

        try:
            completed = subprocess.run(
                ["register-python-argcomplete", cmd],
                stdout=subprocess.PIPE,
                stderr=subprocess.DEVNULL,
                text=True,
                check=False,
            )

            if completed.returncode == 0 and completed.stdout.strip():
                out_file.write_text(completed.stdout)
                print(f"‚úÖ  {cmd}")
            else:
                print(f"‚ö†Ô∏è  {cmd} (empty output)")
        except Exception:
            print(f"‚ùå  {cmd} (failed)")
        finally:
            try:
                os.remove(tmp_path)
            except OSError:
                pass

    print(f"\nüéØ All completions written to: {output_dir}")


# ---------------------------------
#  MAIN LOGIC
# ---------------------------------

def main():
    parser = argparse.ArgumentParser(
        description="Generate python-argcomplete completion scripts for rc CLI tools.",
        formatter_class=argparse.RawTextHelpFormatter,
        add_help=False,
    )
    parser.add_argument("-h", "--help", action="help", help="Show help message and exit.")
    argcomplete.autocomplete(parser, always_complete_options=False)
    parser.parse_args()

    ensure_argcomplete_installed()

    script_dir = Path(__file__).resolve().parent
    completions_dir = script_dir / ".." / "completions"

    commands = get_commands()
    generate_completions(commands, completions_dir)


if __name__ == "__main__":
    main()

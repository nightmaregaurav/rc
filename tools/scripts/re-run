#!/usr/bin/env -S uv run --script

# /// script
# requires-python = ">=3.14"
# dependencies = [
#     "argcomplete",
# ]
# ///

import os
import argparse
from pathlib import Path

import argcomplete
import re
import subprocess
import time
import sys
import signal
from shutil import get_terminal_size, which


def run_in_invoking_shell(commands: list[str]) -> subprocess.CompletedProcess:
    shell_path = os.environ.get("CURRENT_SHELL")
    if shell_path and which(shell_path):
        # Convert list -> properly escaped string
        cmd_str = " ".join(commands)
        # Pass the shell binary as executable, command as string
        return subprocess.run([shell_path, "-i", "-c", cmd_str])
    else:
        # Windows fallback, shell=True is required, command must be string
        return subprocess.run(commands, shell=True)


def wrap_text(text, character):
    return character + text + character


def parse_time_expression(expr: str) -> float:
    """Parses a time expression like '1h3s', '2minutes', '5m', etc. into seconds."""
    expr = expr.lower().replace(" ", "")
    pattern = r"(?:(\d+)\s*(?:h|hour|hours))?|(?:(\d+)\s*(?:m|minute|minutes))?|(?:(\d+)\s*(?:s|second|seconds))?"
    matches = re.findall(pattern, expr)
    if not matches:
        raise ValueError(f"Invalid time format: '{expr}'")

    total_seconds = 0
    for h, m, s in matches:
        if h:
            total_seconds += int(h) * 3600
        if m:
            total_seconds += int(m) * 60
        if s:
            total_seconds += int(s)
    if total_seconds == 0:
        raise ValueError(f"No valid time components found in '{expr}'")
    ms = total_seconds * 1000
    return ms


def main():
    parser = argparse.ArgumentParser(
        description="Repeats a given command at regular intervals.",
        formatter_class=argparse.RawTextHelpFormatter,
        add_help=False,
    )

    parser.add_argument(
        "--every", "-e",
        required=True,
        metavar="<time>",
        help="Time interval between runs (e.g. 5s, 2m, 1h30s, 3hours10seconds)",
    )

    parser.add_argument(
        "command",
        nargs=argparse.REMAINDER,
        help="Command to execute repeatedly.",
    )

    parser.add_argument(
        "-h", "--help",
        action="help",
        help="Show help message and exit.",
    )

    argcomplete.autocomplete(parser, always_complete_options=False)
    args = parser.parse_args()

    if not args.command:
        print("Error: No command provided to re-run.", file=sys.stderr)
        sys.exit(1)

    command = " ".join(args.command)

    try:
        interval_ms = parse_time_expression(args.every)
    except ValueError as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)

    helper_script_path = Path(__file__).resolve().parent.parent / "helpers" / "re-run"

    commands_to_run = [
        wrap_text(str(helper_script_path), '"'),
        str(interval_ms),
        command
    ]
    run_in_invoking_shell(commands_to_run)

if __name__ == "__main__":
    main()

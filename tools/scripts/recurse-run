#!/usr/bin/env -S uv run --script

# /// script
# requires-python = ">=3.14"
# dependencies = [
#     "argcomplete",
# ]
# ///

import os
import subprocess
from shutil import which
import argparse
from pathlib import Path
import argcomplete


def run_in_invoking_shell(commands: list[str]) -> subprocess.CompletedProcess:
    shell_path = os.environ.get("CURRENT_SHELL")
    if shell_path and which(shell_path):
        # Convert list -> properly escaped string
        cmd_str = " ".join(commands)
        # Pass the shell binary as executable, command as string
        return subprocess.run([shell_path, "-i", "-c", cmd_str])
    else:
        # Windows fallback, shell=True is required, command must be string
        return subprocess.run(commands, shell=True)


def wrap_text(text, character):
    return character + text + character


def main():
    parser = argparse.ArgumentParser(
        description="Starts a session to recursively run passed commands in all folders in the current directory.\nYou can also pass an initial command to run before the recursion starts.",
        formatter_class=argparse.RawTextHelpFormatter,
        add_help=False,
    )

    parser.add_argument(
        "command",
        nargs=argparse.REMAINDER,
        help="Initial command to execute before starting recursion.",
    )

    parser.add_argument(
        "-h", "--help",
        action="help",
        help="Show help message and exit.",
    )

    argcomplete.autocomplete(parser, always_complete_options=False)
    args = parser.parse_args()

    initial_command = " ".join(args.command)
    current_directory = os.getcwd()

    helper_script_path = Path(__file__).resolve().parent.parent / "helpers" / "recurse-run"

    commands_to_run = [
        wrap_text(str(helper_script_path), '"'),
        wrap_text(current_directory, '"'),
    ]
    if initial_command:
        commands_to_run.append(initial_command)
    run_in_invoking_shell(commands_to_run)


if __name__ == "__main__":
    main()

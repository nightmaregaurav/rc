#!/usr/bin/env -S uv run --script

# /// script
# requires-python = ">=3.14"
# dependencies = [
#   "argcomplete",
#   "requests",
# ]
# ///

import argparse
import http.server
import socketserver
import urllib.request
import urllib.error
import urllib.parse
import sys
import os
import argcomplete
import requests


class ProxyFallbackHandler(http.server.SimpleHTTPRequestHandler):
    """Custom handler that optionally proxies missing files to another server."""

    def __init__(self, *args, proxy=None, dirlist=True, **kwargs):
        self.proxy = proxy
        self.dirlist = dirlist
        super().__init__(*args, **kwargs)

    def list_directory(self, path):
        if not self.dirlist:
            self.send_error(403, "Directory listing disabled.")
            return None
        return super().list_directory(path)

    def do_GET(self):
        """Serve GET request; proxy fallback if 404."""
        # Try to serve local file first
        path = self.translate_path(self.path)
        if os.path.exists(path):
            return super().do_GET()

        # If file not found and proxy is defined, fallback
        if self.proxy:
            try:
                proxied = urllib.parse.urljoin(self.proxy, self.path.lstrip("/"))
                resp = requests.get(proxied, stream=True, timeout=5)
                self.send_response(resp.status_code)
                for key, val in resp.headers.items():
                    if key.lower() not in ("transfer-encoding", "content-encoding", "content-length", "connection"):
                        self.send_header(key, val)
                self.end_headers()
                self.wfile.write(resp.content)
                return
            except Exception as e:
                self.send_error(502, f"Proxy failed: {e}")
                return

        # Default 404 if not found and no proxy
        self.send_error(404, f"File not found: {self.path}")


def main():
    parser = argparse.ArgumentParser(
        description="Serve the current directory over HTTP with optional proxy and directory listing.",
        add_help=False,
    )

    parser.add_argument(
        "-h", "--help",
        action="help",
        help="Show help message and exit.",
    )

    parser.add_argument("-P", "--port", type=int, default=4200, help="Port number to listen on (default: 4200)")
    parser.add_argument("-H", "--host", default="localhost", help="Host address to bind (default: localhost)")
    parser.add_argument("-X", "--proxy", default=None, help="Proxy fallback URL (default: none)")
    parser.add_argument("-D", "--dirlist", choices=["true", "false"], default="true", help="Enable directory listing (default: true)")

    argcomplete.autocomplete(parser, always_complete_options=False)
    args = parser.parse_args()

    dirlist_enabled = args.dirlist.lower() == "true"

    handler_factory = lambda *h_args, **h_kwargs: ProxyFallbackHandler(
        *h_args, proxy=args.proxy, dirlist=dirlist_enabled, **h_kwargs
    )

    try:
        with socketserver.TCPServer((args.host, args.port), handler_factory) as httpd:
            addr = f"http://{args.host}:{args.port}"
            print(f"Serving directory: {os.getcwd()}")
            print(f"Listening on: {addr}")
            if args.proxy:
                print(f"Proxy fallback: {args.proxy}")
            print(f"Directory listing: {'enabled' if dirlist_enabled else 'disabled'}")
            print("Press Ctrl+C to stop.")
            httpd.serve_forever()
    except OSError as e:
        sys.exit(f"Error: Failed to start server on port {args.port} ({e})")
    except KeyboardInterrupt:
        print("\nServer stopped.")


if __name__ == "__main__":
    main()

#!/usr/bin/env -S uv run --script

# /// script
# requires-python = ">=3.14"
# dependencies = [
#     "argcomplete",
#     "pynput",
# ]
# ///

import argparse
import argcomplete
import re
import sys
import time
from pynput.keyboard import Controller, Key

keyboard = Controller()

MODIFIERS = {
    "RETURN": "ENTER",
    "META": "CMD",
    "META_L": "CMD_L",
    "META_R": "CMD_R",
}


# ---------------------------
#  COMPLETION & VALIDATION
# ---------------------------

def complete_key(prefix, **_):
    keys = get_valid_key_names()
    return [k for k in keys if k.startswith(prefix.upper())]


def get_valid_key_names():
    """
    Returns all valid key names from pynput plus custom modifier aliases.
    """
    base_keys = [key.name.upper() for key in Key]
    all_keys = sorted(set(base_keys + list(MODIFIERS.keys()) + list(MODIFIERS.values())))
    return all_keys


def get_key_from_name(name: str):
    valid_keys = get_valid_key_names()
    if name.upper() not in valid_keys:
        print(f"Warning: Key '{name}' is not a valid pynput Key.")
        return None
    try:
        return getattr(Key, name.lower())
    except AttributeError:
        print(f"Warning: Key '{name}' not found in pynput Key.")
        return None


# ---------------------------
#  TOKENIZER AND HANDLER
# ---------------------------

def tokenize(text: str) -> list[str]:
    """
    Splits the text into HTML-like tags and text segments.
    E.g. "Hello<SHIFT>World</SHIFT>" -> ["Hello", "<SHIFT>", "World", "</SHIFT>"]
    """
    pattern = re.compile(r'(</?[^>]+>|[^<]+)')
    return re.findall(pattern, text)


def handle_special_token(token: str):
    """
    Handles tokens like <SHIFT>, </SHIFT>, <ENTER/>, etc.
    """
    is_self_closing = token.endswith('/')
    is_closing = token.startswith('/')
    original_key_name = token.strip('/')
    key_name = MODIFIERS.get(original_key_name, original_key_name)
    key = get_key_from_name(key_name)

    if not key:
        return

    if is_self_closing:
        print(f"Pressing and releasing key: {key_name}")
        keyboard.press(key)
        keyboard.release(key)
    elif is_closing:
        print(f"Releasing key: {key_name}")
        keyboard.release(key)
    else:
        print(f"Pressing key: {key_name}")
        keyboard.press(key)


def start_typing(tokens: list[str], delay: float):
    """
    Types out plain text and processes HTML-like key tags with optional delay.
    """
    special_token_re = re.compile(r'^<(/?)([A-Za-z_]+)(/?)>$')

    normalize_next_token = False
    for token in tokens:
        is_special_token = special_token_re.match(token)
        if is_special_token and not normalize_next_token:
            token = token.strip('<>')
            is_normalizer_flag = token.strip('/') == '__'
            if is_normalizer_flag:
                normalize_next_token = True
                continue
            is_delay_flag = token.strip('/') == '_'
            if is_delay_flag:
                wait = delay if delay > 0 else 0.5
                print(f"Waiting for {wait:.2f}s")
                time.sleep(wait)
            else:
                handle_special_token(token)
        else:
            if normalize_next_token and is_special_token:
                normalize_next_token = False
            for char in token:
                print(f"Typing character: {char}")
                keyboard.type(char)
                if delay > 0:
                    time.sleep(delay)


# ---------------------------
#  MAIN LOGIC
# ---------------------------

def execute_autotype(input_text: str, delay: float, initial_delay: float):
    if initial_delay > 0:
        print(f"Waiting {initial_delay:.2f}s before starting...")
        time.sleep(initial_delay)

    tokens = tokenize(input_text)
    start_typing(tokens, delay)


def list_available_keys():
    keys = get_valid_key_names()
    print("Available keys:")
    for i, k in enumerate(keys, 1):
        print(f"{i:3}. {k}")
    print(f"\nTotal: {len(keys)} keys.")
    special_tags = {
        "<_> or <_/> or </_>": "Introduce a delay (default 0.5s) between keystrokes. Modifiable with --delay.",
        "<__> or <__/> or </__>": "Normalize the next token (treat special tags as normal text).",
    }
    print("\nSpecial tags:")
    for i, (tag, desc) in enumerate(special_tags.items(), 1):
        print(f"{i:3}. {tag}: {desc}")
    sys.exit(0)


def main():
    parser = argparse.ArgumentParser(
        description="Simulates keyboard typing with HTML-like tags for special keys",
        formatter_class=argparse.RawTextHelpFormatter,
        add_help=False,
    )

    parser.add_argument("-h", "--help", action="help", help="Show help message and exit.")
    parser.add_argument("-l", "--list", action="store_true", help="List all available key names and exit.")
    parser.add_argument(
        "-d",
        "--delay",
        type=float,
        default=0.0,
        help="Delay in seconds between keystrokes (default: 0).",
    )
    parser.add_argument(
        "-i",
        "--initial-delay",
        type=float,
        default=0.0,
        help="Initial delay in seconds before typing starts (default: 0).",
    )
    parser.add_argument(
        "command",
        type=str,
        nargs="?",
        help="Typewriter command string with valid syntax inside quotes. Example: 'Hello<SHIFT>World</SHIFT><ENTER/>'.",
    )

    argcomplete.autocomplete(parser, always_complete_options=False)
    args = parser.parse_args()

    if args.list:
        list_available_keys()
        sys.exit(0)

    if not args.command:
        print("Error: No command provided. Use -h for help or -l to list keys.")
        sys.exit(1)

    if args.delay < 0 or args.initial_delay < 0:
        print("Error: Delay values cannot be negative.")
        sys.exit(1)

    try:
        execute_autotype(args.command, args.delay, args.initial_delay)
    except Exception as e:
        print(f"Error: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()

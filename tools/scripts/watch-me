#!/usr/bin/env -S uv run --script

# /// script
# requires-python = "==3.13"
# dependencies = [
#   "fastapi",
#   "uvicorn",
#   "opencv-python",
#   "mss",
#   "numpy",
#   "sounddevice",
#   "pyautogui",
# ]
# ///

import argparse
import time
import threading
import queue

import cv2
import numpy as np
import mss
import sounddevice as sd
import pyautogui

from fastapi import FastAPI
from fastapi.responses import StreamingResponse, HTMLResponse
import uvicorn


# ============================================================
# Global state
# ============================================================

app = FastAPI()
stop_event = threading.Event()

video_streams: dict[str, "FrameBroadcaster"] = {}
audio_streams: dict[str, "AudioBroadcaster"] = {}


# ============================================================
# Broadcasters
# ============================================================

class FrameBroadcaster:
    def __init__(self):
        self.clients: set[queue.Queue[bytes]] = set()
        self.lock = threading.Lock()

    def register(self):
        q = queue.Queue(maxsize=2)
        with self.lock:
            self.clients.add(q)
        return q

    def unregister(self, q):
        with self.lock:
            self.clients.discard(q)

    def broadcast(self, frame: bytes):
        with self.lock:
            for q in list(self.clients):
                if not q.full():
                    q.put_nowait(frame)


class AudioBroadcaster:
    def __init__(self):
        self.clients: set[queue.Queue[bytes]] = set()
        self.lock = threading.Lock()

    def register(self):
        q = queue.Queue(maxsize=10)
        with self.lock:
            self.clients.add(q)
        return q

    def unregister(self, q):
        with self.lock:
            self.clients.discard(q)

    def broadcast(self, chunk: bytes):
        with self.lock:
            for q in list(self.clients):
                if not q.full():
                    q.put_nowait(chunk)


# ============================================================
# Cursor overlay
# ============================================================

def draw_cursor(frame: np.ndarray, monitor: dict) -> np.ndarray:
    x, y = pyautogui.position()

    mx, my = monitor["left"], monitor["top"]
    mw, mh = monitor["width"], monitor["height"]

    if not (mx <= x < mx + mw and my <= y < my + mh):
        return frame

    cx, cy = int(x - mx), int(y - my)

    cv2.line(frame, (cx - 10, cy), (cx + 10, cy), (0, 0, 255), 2)
    cv2.line(frame, (cx, cy - 10), (cx, cy + 10), (0, 0, 255), 2)
    return frame


# ============================================================
# Capture loops
# ============================================================

def screen_capture_loop(monitor, broadcaster):
    with mss.mss() as sct:
        while not stop_event.is_set():
            img = np.array(sct.grab(monitor))
            frame = cv2.cvtColor(img, cv2.COLOR_BGRA2BGR)
            frame = draw_cursor(frame, monitor)

            _, jpg = cv2.imencode(".jpg", frame)
            broadcaster.broadcast(
                b"--frame\r\n"
                b"Content-Type: image/jpeg\r\n\r\n"
                + jpg.tobytes()
                + b"\r\n"
            )


def camera_capture_loop(index, broadcaster):
    cap = cv2.VideoCapture(index)
    if not cap.isOpened():
        return
    try:
        while not stop_event.is_set():
            ok, frame = cap.read()
            if not ok:
                break
            _, jpg = cv2.imencode(".jpg", frame)
            broadcaster.broadcast(
                b"--frame\r\n"
                b"Content-Type: image/jpeg\r\n\r\n"
                + jpg.tobytes()
                + b"\r\n"
            )
    finally:
        cap.release()


def audio_capture_loop(device_index, broadcaster):
    def callback(indata, *_):
        broadcaster.broadcast(indata.tobytes())

    with sd.InputStream(device=device_index, samplerate=44100, channels=1, callback=callback):
        while not stop_event.is_set():
            time.sleep(0.1)


# ============================================================
# Client generators
# ============================================================

def mjpeg_client(broadcaster):
    q = broadcaster.register()
    try:
        while not stop_event.is_set():
            yield q.get()
    finally:
        broadcaster.unregister(q)


def audio_client(broadcaster):
    q = broadcaster.register()
    try:
        while not stop_event.is_set():
            yield q.get()
    finally:
        broadcaster.unregister(q)


# ============================================================
# API routes
# ============================================================

@app.get("/video/{stream_id}")
def video_feed(stream_id: str):
    return StreamingResponse(
        mjpeg_client(video_streams[stream_id]),
        media_type="multipart/x-mixed-replace; boundary=frame",
    )


@app.get("/audio/{stream_id}")
def audio_feed(stream_id: str):
    return StreamingResponse(
        audio_client(audio_streams[stream_id]),
        media_type="application/octet-stream",
    )


# ============================================================
# Viewer pages (audio merged here)
# ============================================================

@app.get("/view/camera/{cam_id}", response_class=HTMLResponse)
def view_camera(cam_id: int):
    return f"""
<!DOCTYPE html>
<html>
<body>
<h2>Camera {cam_id} (Mic)</h2>
<img src="/video/camera-{cam_id}" style="width:100%">
<audio src="/audio/mic" autoplay controls></audio>
</body>
</html>
"""


@app.get("/view/screen/{screen_id}", response_class=HTMLResponse)
def view_screen(screen_id: int):
    return f"""
<!DOCTYPE html>
<html>
<body>
<h2>Screen {screen_id} (Speaker)</h2>
<img src="/video/screen-{screen_id}" style="width:100%">
<audio src="/audio/speaker" autoplay controls></audio>
</body>
</html>
"""


# ============================================================
# Discovery helpers
# ============================================================

def discover_cameras():
    cams = []
    for i in range(10):
        cap = cv2.VideoCapture(i)
        if cap.isOpened():
            cams.append(i)
            cap.release()
    return cams


def discover_screens():
    with mss.mss() as sct:
        return sct.monitors[1:]


def find_loopback_device():
    for i, d in enumerate(sd.query_devices()):
        if "loopback" in d["name"].lower() or "monitor" in d["name"].lower():
            return i
    return None


# ============================================================
# Main
# ============================================================

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("-s", "--screen", action="store_true")
    parser.add_argument("-c", "--camera", action="store_true")
    parser.add_argument("-m", "--mic", action="store_true")
    parser.add_argument("-p", "--speaker", action="store_true")
    args = parser.parse_args()

    if not any(vars(args).values()):
        args.screen = True

    if args.screen:
        for i, m in enumerate(discover_screens()):
            b = FrameBroadcaster()
            video_streams[f"screen-{i}"] = b
            threading.Thread(target=screen_capture_loop, args=(m, b), daemon=True).start()
            print(f"Screen {i}: http://localhost:8000/view/screen/{i}")

    if args.camera:
        for cam in discover_cameras():
            b = FrameBroadcaster()
            video_streams[f"camera-{cam}"] = b
            threading.Thread(target=camera_capture_loop, args=(cam, b), daemon=True).start()
            print(f"Camera {cam}: http://localhost:8000/view/camera/{cam}")

    if args.mic:
        b = AudioBroadcaster()
        audio_streams["mic"] = b
        threading.Thread(target=audio_capture_loop, args=(None, b), daemon=True).start()

    if args.speaker:
        loop = find_loopback_device()
        if loop is not None:
            b = AudioBroadcaster()
            audio_streams["speaker"] = b
            threading.Thread(target=audio_capture_loop, args=(loop, b), daemon=True).start()

    print("\nServer running at http://localhost:8000\n")

    try:
        uvicorn.run(app, host="0.0.0.0", port=8000)
    finally:
        stop_event.set()


if __name__ == "__main__":
    main()
